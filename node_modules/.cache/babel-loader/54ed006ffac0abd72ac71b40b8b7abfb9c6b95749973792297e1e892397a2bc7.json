{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Varshitha Uppu\\\\Desktop\\\\projects\\\\graph-algorithms-visualizer\\\\src\\\\PathfindingVisualizer\\\\PathfindingVisualizer.jsx\";\nimport React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra } from '../algorithms/dijkstra';\nimport { AStar } from '../algorithms/aStar';\nimport { dfs } from '../algorithms/dfs';\nimport { bfs } from '../algorithms/bfs';\nimport { randomdfs } from '../algorithms/randomdfs';\nimport { swarm } from '../algorithms/swarm';\n//import './dropdown.js';\nimport './PathfindingVisualizer.css';\nimport Dropdown from './Dropdown.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    /******************** Set up the initial grid ********************/\n    this.getInitialGrid = (rowCount = this.state.ROW_COUNT, colCount = this.state.COLUMN_COUNT) => {\n      const initialGrid = [];\n      for (let row = 0; row < rowCount; row++) {\n        const currentRow = [];\n        for (let col = 0; col < colCount; col++) {\n          currentRow.push(this.createNode(row, col));\n        }\n        initialGrid.push(currentRow);\n      }\n      return initialGrid;\n    };\n    this.createNode = (row, col) => {\n      return {\n        row,\n        col,\n        isStart: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n        isFinish: row === this.state.FINISH_NODE_ROW && col === this.state.FINISH_NODE_COL,\n        distance: Infinity,\n        distanceToFinishNode: Math.abs(this.state.FINISH_NODE_ROW - row) + Math.abs(this.state.FINISH_NODE_COL - col),\n        isVisited: false,\n        isWall: false,\n        previousNode: null,\n        isNode: true\n      };\n    };\n    this.state = {\n      grid: [],\n      START_NODE_ROW: 5,\n      FINISH_NODE_ROW: 5,\n      START_NODE_COL: 5,\n      FINISH_NODE_COL: 15,\n      mouseIsPressed: false,\n      ROW_COUNT: 25,\n      COLUMN_COUNT: 35,\n      MOBILE_ROW_COUNT: 10,\n      MOBILE_COLUMN_COUNT: 20,\n      isRunning: false,\n      isStartNode: false,\n      isFinishNode: false,\n      isWallNode: false,\n      currRow: 0,\n      currCol: 0,\n      isDesktopView: true\n    };\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({\n      grid\n    });\n  }\n  toggleIsRunning() {\n    this.setState({\n      isRunning: !this.state.isRunning\n    });\n  }\n  toggleView() {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.clearWalls();\n      const isDesktopView = !this.state.isDesktopView;\n      let grid;\n      if (isDesktopView) {\n        grid = this.getInitialGrid(this.state.ROW_COUNT, this.state.COLUMN_COUNT);\n        this.setState({\n          isDesktopView,\n          grid\n        });\n      } else {\n        if (this.state.START_NODE_ROW > this.state.MOBILE_ROW_COUNT || this.state.FINISH_NODE_ROW > this.state.MOBILE_ROW_COUNT || this.state.START_NODE_COL > this.state.MOBILE_COLUMN_COUNT || this.state.FINISH_NODE_COL > this.state.MOBILE_COLUMN_COUNT) {\n          alert('Start & Finish Nodes Must Be within 10 Rows x 20 Columns');\n        } else {\n          grid = this.getInitialGrid(this.state.MOBILE_ROW_COUNT, this.state.MOBILE_COLUMN_COUNT);\n          this.setState({\n            isDesktopView,\n            grid\n          });\n        }\n      }\n    }\n  }\n  /******************** Control mouse events ********************/\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (document.getElementById(`node-${row}-${col}`).className === 'node node-start') {\n          this.setState({\n            mouseIsPressed: true,\n            isStartNode: true,\n            currRow: row,\n            currCol: col\n          });\n        } else if (document.getElementById(`node-${row}-${col}`).className === 'node node-finish') {\n          this.setState({\n            mouseIsPressed: true,\n            isFinishNode: true,\n            currRow: row,\n            currCol: col\n          });\n        } else {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mouseIsPressed: true,\n            isWallNode: true,\n            currRow: row,\n            currCol: col\n          });\n        }\n      } else {\n        this.clearGrid();\n      }\n    }\n  }\n  isGridClear() {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n        if (nodeClassName === 'node node-visited' || nodeClassName === 'node node-shortest-path') {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (this.state.mouseIsPressed) {\n        const nodeClassName = document.getElementById(`node-${row}-${col}`).className;\n        if (this.state.isStartNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevStartNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevStartNode.isStart = false;\n            document.getElementById(`node-${this.state.currRow}-${this.state.currCol}`).className = 'node';\n            this.setState({\n              currRow: row,\n              currCol: col\n            });\n            const currStartNode = this.state.grid[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          }\n          this.setState({\n            START_NODE_ROW: row,\n            START_NODE_COL: col\n          });\n        } else if (this.state.isFinishNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevFinishNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevFinishNode.isFinish = false;\n            document.getElementById(`node-${this.state.currRow}-${this.state.currCol}`).className = 'node';\n            this.setState({\n              currRow: row,\n              currCol: col\n            });\n            const currFinishNode = this.state.grid[row][col];\n            currFinishNode.isFinish = true;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          }\n          this.setState({\n            FINISH_NODE_ROW: row,\n            FINISH_NODE_COL: col\n          });\n        } else if (this.state.isWallNode) {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid\n          });\n        }\n      }\n    }\n  }\n  handleMouseUp(row, col) {\n    if (!this.state.isRunning) {\n      this.setState({\n        mouseIsPressed: false\n      });\n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({\n          isStartNode,\n          START_NODE_ROW: row,\n          START_NODE_COL: col\n        });\n      } else if (this.state.isFinishNode) {\n        const isFinishNode = !this.state.isFinishNode;\n        this.setState({\n          isFinishNode,\n          FINISH_NODE_ROW: row,\n          FINISH_NODE_COL: col\n        });\n      }\n      this.getInitialGrid();\n    }\n  }\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({\n        isStartNode,\n        mouseIsPressed: false\n      });\n    } else if (this.state.isFinishNode) {\n      const isFinishNode = !this.state.isFinishNode;\n      this.setState({\n        isFinishNode,\n        mouseIsPressed: false\n      });\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({\n        isWallNode,\n        mouseIsPressed: false\n      });\n      this.getInitialGrid();\n    }\n  }\n\n  /******************** Clear Board/Walls ********************/\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n          if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish' && nodeClassName !== 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n          if (nodeClassName === 'node node-finish') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n          }\n          if (nodeClassName === 'node node-start') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n  clearWalls() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n          if (nodeClassName === 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n            node.isWall = false;\n          }\n        }\n      }\n    }\n  }\n  fillWalls() {\n    this.clearGrid();\n    this.clearWalls();\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n          if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish') {\n            if (Math.floor(Math.random() * 10) % 5 === 0) {\n              document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall';\n              node.isWall = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /******************** Create Animations ********************/\n  visualize(algo) {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.toggleIsRunning();\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n      const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n      let visitedNodesInOrder;\n      switch (algo) {\n        case 'Dijkstra':\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n          break;\n        case 'AStar':\n          visitedNodesInOrder = AStar(grid, startNode, finishNode);\n          break;\n        case 'BFS':\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\n          break;\n        case 'DFS':\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\n          break;\n        case 'RANDOMDFS':\n          visitedNodesInOrder = randomdfs(grid, startNode, finishNode);\n          break;\n        case 'SWARM':\n          visitedNodesInOrder = swarm(grid, startNode, finishNode);\n          break;\n        default:\n          // should never get here\n          break;\n      }\n      if (1) {\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        nodesInShortestPathOrder.push('end');\n        this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n      }\n    }\n  }\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n        if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish') {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }\n      }, 10 * i);\n    }\n  }\n\n  /******************** Create path from start to finish ********************/\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      if (nodesInShortestPathOrder[i] === 'end') {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 50);\n      } else {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n          if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish') {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n          }\n        }, i * 40);\n      }\n    }\n  }\n  render() {\n    const {\n      grid,\n      mouseIsPressed\n    } = this.state;\n    var currAlgo = -1;\n    var setAlgo = i => {\n      currAlgo = i;\n      console.log(currAlgo);\n      if (currAlgo === 0) this.visualize('AStar');else if (currAlgo === 1) this.visualize('DFS');else if (currAlgo === 2) this.visualize('Dijkstra');else if (currAlgo === 3) this.visualize('BFS');else if (currAlgo === 4) this.visualize('RANDOMDFS');else if (currAlgo === 5) this.visualize('SWARM');\n    };\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"lol\",\n        children: [/*#__PURE__*/_jsxDEV(\"nav\", {\n          className: \"navbar navbar-expand-lg\",\n          children: [/*#__PURE__*/_jsxDEV(\"a\", {\n            className: \"navbar-brand\",\n            href: \"/\",\n            children: /*#__PURE__*/_jsxDEV(\"h3\", {\n              children: \"Graph Algorithms Visualizer\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 450,\n              columnNumber: 13\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 449,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"navbar-toggler\",\n            type: \"button\",\n            \"data-toggle\": \"collapse\",\n            \"data-target\": \"#navbarNav\",\n            \"aria-controls\": \"navbarNav\",\n            \"aria-expanded\": \"false\",\n            \"aria-label\": \"Toggle navigation\",\n            children: /*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"navbar-toggler-icon\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 460,\n              columnNumber: 13\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 452,\n            columnNumber: 11\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 448,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(Dropdown, {\n          handleChange: setAlgo\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 464,\n          columnNumber: 7\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"button\",\n          className: \"btn btn-danger\",\n          onClick: () => this.clearGrid(),\n          children: \"Clear Grid\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 466,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"button\",\n          className: \"btn btn-warning\",\n          onClick: () => this.clearWalls(),\n          children: \"Clear Walls\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 472,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"button\",\n          className: \"btn btn-warning\",\n          onClick: () => this.fillWalls(),\n          children: \"Fill Walls\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 478,\n          columnNumber: 9\n        }, this), this.state.isDesktopView ? /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"button\",\n          className: \"btn btn-light\",\n          onClick: () => this.toggleView(),\n          children: \"Mobile View\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 485,\n          columnNumber: 11\n        }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"button\",\n          className: \"btn btn-dark\",\n          onClick: () => this.toggleView(),\n          children: \"Desktop View\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 492,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 447,\n        columnNumber: 7\n      }, this), /*#__PURE__*/_jsxDEV(\"table\", {\n        className: \"grid-container\",\n        onMouseLeave: () => this.handleMouseLeave(),\n        children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n          className: \"grid\",\n          children: grid.map((row, rowIdx) => {\n            return /*#__PURE__*/_jsxDEV(\"tr\", {\n              children: row.map((node, nodeIdx) => {\n                const {\n                  row,\n                  col,\n                  isFinish,\n                  isStart,\n                  isWall\n                } = node;\n                return /*#__PURE__*/_jsxDEV(Node, {\n                  col: col,\n                  isFinish: isFinish,\n                  isStart: isStart,\n                  isWall: isWall,\n                  mouseIsPressed: mouseIsPressed,\n                  onMouseDown: (row, col) => this.handleMouseDown(row, col),\n                  onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n                  onMouseUp: () => this.handleMouseUp(row, col),\n                  row: row\n                }, nodeIdx, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 510,\n                  columnNumber: 23\n                }, this);\n              })\n            }, rowIdx, false, {\n              fileName: _jsxFileName,\n              lineNumber: 506,\n              columnNumber: 17\n            }, this);\n          })\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 503,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 500,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 446,\n      columnNumber: 7\n    }, this);\n  }\n}\n\n/******************** Create Walls ********************/\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  if (!node.isStart && !node.isFinish && node.isNode) {\n    const newNode = {\n      ...node,\n      isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called after the pathfinding methods.\nfunction getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["React","Component","Node","dijkstra","AStar","dfs","bfs","randomdfs","swarm","Dropdown","jsxDEV","_jsxDEV","PathfindingVisualizer","constructor","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","row","currentRow","col","push","createNode","isStart","START_NODE_ROW","START_NODE_COL","isFinish","FINISH_NODE_ROW","FINISH_NODE_COL","distance","Infinity","distanceToFinishNode","Math","abs","isVisited","isWall","previousNode","isNode","grid","mouseIsPressed","MOBILE_ROW_COUNT","MOBILE_COLUMN_COUNT","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","isDesktopView","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","componentDidMount","setState","toggleView","clearGrid","clearWalls","alert","isGridClear","document","getElementById","className","newGrid","getNewGridWithWallToggled","node","nodeClassName","handleMouseEnter","prevStartNode","currStartNode","prevFinishNode","currFinishNode","handleMouseUp","slice","fillWalls","floor","random","visualize","algo","startNode","finishNode","visitedNodesInOrder","nodesInShortestPathOrder","getNodesInShortestPathOrder","animate","i","length","setTimeout","animateShortestPath","render","currAlgo","setAlgo","console","log","children","href","fileName","_jsxFileName","lineNumber","columnNumber","type","handleChange","onClick","onMouseLeave","map","rowIdx","nodeIdx","onMouseDown","onMouseEnter","onMouseUp","newNode","currentNode","unshift"],"sources":["C:/Users/Varshitha Uppu/Desktop/projects/graph-algorithms-visualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx"],"sourcesContent":["import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra} from '../algorithms/dijkstra';\nimport {AStar} from '../algorithms/aStar';\nimport {dfs} from '../algorithms/dfs';\nimport {bfs} from '../algorithms/bfs';\nimport {randomdfs} from '../algorithms/randomdfs';\nimport {swarm} from '../algorithms/swarm';\n//import './dropdown.js';\nimport './PathfindingVisualizer.css';\nimport Dropdown from './Dropdown.js';\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      START_NODE_ROW: 5,\n      FINISH_NODE_ROW: 5,\n      START_NODE_COL: 5,\n      FINISH_NODE_COL: 15,\n      mouseIsPressed: false,\n      ROW_COUNT: 25,\n      COLUMN_COUNT: 35,\n      MOBILE_ROW_COUNT: 10,\n      MOBILE_COLUMN_COUNT: 20,\n      isRunning: false,\n      isStartNode: false,\n      isFinishNode: false,\n      isWallNode: false,\n      currRow: 0,\n      currCol: 0,\n      isDesktopView: true,\n    };\n    \n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({grid});\n  }\n\n  toggleIsRunning() {\n    this.setState({isRunning: !this.state.isRunning});\n  }\n\n  toggleView() {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.clearWalls();\n      const isDesktopView = !this.state.isDesktopView;\n      let grid;\n      if (isDesktopView) {\n        grid = this.getInitialGrid(\n          this.state.ROW_COUNT,\n          this.state.COLUMN_COUNT,\n        );\n        this.setState({isDesktopView, grid});\n      } else {\n        if (\n          this.state.START_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\n          this.state.FINISH_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\n          this.state.START_NODE_COL > this.state.MOBILE_COLUMN_COUNT ||\n          this.state.FINISH_NODE_COL > this.state.MOBILE_COLUMN_COUNT\n        ) {\n          alert('Start & Finish Nodes Must Be within 10 Rows x 20 Columns');\n        } else {\n          grid = this.getInitialGrid(\n            this.state.MOBILE_ROW_COUNT,\n            this.state.MOBILE_COLUMN_COUNT,\n          );\n          this.setState({isDesktopView, grid});\n        }\n      }\n    }\n  }\n\n  /******************** Set up the initial grid ********************/\n  getInitialGrid = (\n    rowCount = this.state.ROW_COUNT,\n    colCount = this.state.COLUMN_COUNT,\n  ) => {\n    const initialGrid = [];\n    for (let row = 0; row < rowCount; row++) {\n      const currentRow = [];\n      for (let col = 0; col < colCount; col++) {\n        currentRow.push(this.createNode(row, col));\n      }\n      initialGrid.push(currentRow);\n    }\n    return initialGrid;\n  };\n\n  createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart:\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n      isFinish:\n        row === this.state.FINISH_NODE_ROW &&\n        col === this.state.FINISH_NODE_COL,\n      distance: Infinity,\n      distanceToFinishNode:\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\n        Math.abs(this.state.FINISH_NODE_COL - col),\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      isNode: true,\n    };\n  };\n\n  /******************** Control mouse events ********************/\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          'node node-start'\n        ) {\n          this.setState({\n            mouseIsPressed: true,\n            isStartNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        } else if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          'node node-finish'\n        ) {\n          this.setState({\n            mouseIsPressed: true,\n            isFinishNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        } else {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mouseIsPressed: true,\n            isWallNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        }\n      } else {\n        this.clearGrid();\n      }\n    }\n  }\n\n  isGridClear() {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(\n          `node-${node.row}-${node.col}`,\n        ).className;\n        if (\n          nodeClassName === 'node node-visited' ||\n          nodeClassName === 'node node-shortest-path'\n        ) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (this.state.mouseIsPressed) {\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\n          .className;\n        if (this.state.isStartNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevStartNode = this.state.grid[this.state.currRow][\n              this.state.currCol\n            ];\n            prevStartNode.isStart = false;\n            document.getElementById(\n              `node-${this.state.currRow}-${this.state.currCol}`,\n            ).className = 'node';\n\n            this.setState({currRow: row, currCol: col});\n            const currStartNode = this.state.grid[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              'node node-start';\n          }\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col});\n        } else if (this.state.isFinishNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevFinishNode = this.state.grid[this.state.currRow][\n              this.state.currCol\n            ];\n            prevFinishNode.isFinish = false;\n            document.getElementById(\n              `node-${this.state.currRow}-${this.state.currCol}`,\n            ).className = 'node';\n\n            this.setState({currRow: row, currCol: col});\n            const currFinishNode = this.state.grid[row][col];\n            currFinishNode.isFinish = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              'node node-finish';\n          }\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col});\n        } else if (this.state.isWallNode) {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({grid: newGrid});\n        }\n      }\n    }\n  }\n\n  handleMouseUp(row, col) {\n    if (!this.state.isRunning) {\n      this.setState({mouseIsPressed: false});\n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col});\n      } else if (this.state.isFinishNode) {\n        const isFinishNode = !this.state.isFinishNode;\n        this.setState({\n          isFinishNode,\n          FINISH_NODE_ROW: row,\n          FINISH_NODE_COL: col,\n        });\n      }\n      this.getInitialGrid();\n    }\n  }\n\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({isStartNode, mouseIsPressed: false});\n    } else if (this.state.isFinishNode) {\n      const isFinishNode = !this.state.isFinishNode;\n      this.setState({isFinishNode, mouseIsPressed: false});\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({isWallNode, mouseIsPressed: false});\n      this.getInitialGrid();\n    }\n  }\n\n  /******************** Clear Board/Walls ********************/\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (\n            nodeClassName !== 'node node-start' &&\n            nodeClassName !== 'node node-finish' &&\n            nodeClassName !== 'node node-wall'\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node';\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n          if (nodeClassName === 'node node-finish') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n          }\n          if (nodeClassName === 'node node-start') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  clearWalls() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (nodeClassName === 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node';\n            node.isWall = false;\n          }\n        }\n      }\n    }\n  }\n  fillWalls() {\n    this.clearGrid();\n    this.clearWalls();\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (nodeClassName !== 'node node-start' &&\n          nodeClassName !== 'node node-finish' ) {\n            if(Math.floor(Math.random()*10)%5===0){\n              document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node node-wall';\n            node.isWall = true;\n            }\n          }\n        }\n      }\n    }\n  }\n    \n\n  /******************** Create Animations ********************/\n  visualize(algo) {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.toggleIsRunning();\n      const {grid} = this.state;\n      const startNode =\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n      const finishNode =\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n      let visitedNodesInOrder;\n      switch (algo) {\n        case 'Dijkstra':\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n          break;\n        case 'AStar':\n          visitedNodesInOrder = AStar(grid, startNode, finishNode);\n          break;\n        case 'BFS':\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\n          break;\n        case 'DFS':\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\n          break;\n        case 'RANDOMDFS':\n          visitedNodesInOrder = randomdfs(grid, startNode, finishNode);\n          break;\n        case 'SWARM':\n          visitedNodesInOrder = swarm(grid, startNode, finishNode);\n          break;\n        default:\n          // should never get here\n          break;\n      }\n      if(1){\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n      nodesInShortestPathOrder.push('end');\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n      }\n    }\n  }\n\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    \n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeClassName = document.getElementById(\n          `node-${node.row}-${node.col}`,\n        ).className;\n        if (\n          nodeClassName !== 'node node-start' &&\n          nodeClassName !== 'node node-finish'\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-visited';\n        }\n      }, 10 * i);\n    }\n  \n}\n\n  /******************** Create path from start to finish ********************/\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      if (nodesInShortestPathOrder[i] === 'end') {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 50);\n      } else {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          const nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`,\n          ).className;\n          if (\n            nodeClassName !== 'node node-start' &&\n            nodeClassName !== 'node node-finish'\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node node-shortest-path';\n          }\n        }, i * 40);\n      }\n    }\n  }\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n    var currAlgo = -1;\n    var setAlgo = (i) => {\n      currAlgo = i;\n      console.log(currAlgo);\n      \n        if(currAlgo===0)this.visualize('AStar')\n        else if(currAlgo===1)this.visualize('DFS')\n        else if(currAlgo===2)this.visualize('Dijkstra')\n        else if(currAlgo===3)this.visualize('BFS')\n        else if(currAlgo===4)this.visualize('RANDOMDFS')\n        else if(currAlgo===5)this.visualize('SWARM')\n       \n    }\n    return (\n      <div>\n      <div className=\"lol\">\n        <nav className=\"navbar navbar-expand-lg\">\n          <a className=\"navbar-brand\" href=\"/\">\n            <h3>Graph Algorithms Visualizer</h3>\n          </a>\n          <button\n            className=\"navbar-toggler\"\n            type=\"button\"\n            data-toggle=\"collapse\"\n            data-target=\"#navbarNav\"\n            aria-controls=\"navbarNav\"\n            aria-expanded=\"false\"\n            aria-label=\"Toggle navigation\">\n            <span className=\"navbar-toggler-icon\"></span>\n          </button>\n        </nav>\n        \n      <Dropdown handleChange={setAlgo} />\n      \n        <button\n          type=\"button\"\n          className=\"btn btn-danger\"\n          onClick={() => this.clearGrid()}>\n          Clear Grid\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-warning\"\n          onClick={() => this.clearWalls()}>\n          Clear Walls\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-warning\"\n          onClick={() => this.fillWalls()}>\n          Fill Walls\n        </button>\n        {this.state.isDesktopView ? (\n          <button\n            type=\"button\"\n            className=\"btn btn-light\"\n            onClick={() => this.toggleView()}>\n            Mobile View\n          </button>\n        ) : (\n          <button\n            type=\"button\"\n            className=\"btn btn-dark\"\n            onClick={() => this.toggleView()}>\n            Desktop View\n          </button>\n        )}\n        </div>\n        <table\n          className=\"grid-container\"\n          onMouseLeave={() => this.handleMouseLeave()}>\n          <tbody className=\"grid\">\n            {grid.map((row, rowIdx) => {\n              return (\n                <tr key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const {row, col, isFinish, isStart, isWall} = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseIsPressed}\n                        onMouseDown={(row, col) =>\n                          this.handleMouseDown(row, col)\n                        }\n                        onMouseEnter={(row, col) =>\n                          this.handleMouseEnter(row, col)\n                        }\n                        onMouseUp={() => this.handleMouseUp(row, col)}\n                        row={row}></Node>\n                    );\n                  })}\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n}\n\n/******************** Create Walls ********************/\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  if (!node.isStart && !node.isFinish && node.isNode) {\n    const newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called after the pathfinding methods.\nfunction getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}